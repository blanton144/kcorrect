<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html dir="ltr" lang="en"><head>
<title>kcorrect</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="MediaWiki 1.16.5">
<link rel="stylesheet" href="shared.css" media="screen">
<link rel="stylesheet" href="commonPrint.css" media="print">
<link rel="stylesheet" href="main.css" media="screen">
<link rel="stylesheet" href="index_002.css">
<link rel="stylesheet" href="index_003.css" media="print">
<link rel="stylesheet" href="index_004.css">
<link rel="stylesheet" href="index.css">
<script src="wikibits.js"></script>
<script src="ajax.js"></script>

</head>
<body class="mediawiki ltr ns-0 ns-subject page-Kcorrect skin-monobook">
<div id="globalWrapper">
<div id="column-content"><div id="content">
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading">kcorrect</h1>
	<div id="bodyContent">
		<h3 id="siteSub">From NYU CCPP Wiki</h3>
		<div id="contentSub"></div>
		<!-- start content -->
<ul>
<li class="toclevel-1 tocsection-1"><a href="#General_description"><span class="tocnumber">1</span> <span class="toctext">General description</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#What.27s_new_in_v4"><span class="tocnumber">2</span> <span class="toctext">What's new in v4</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Conditions_of_use"><span class="tocnumber">3</span> <span class="toctext">Conditions of use</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Obtaining_the_software"><span class="tocnumber">4</span> <span class="toctext">Obtaining the software</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Installing_the_software"><span class="tocnumber">5</span> <span class="toctext">Installing the software</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Basic_concept_of_obtaining_K-corrections"><span class="tocnumber">6</span> <span class="toctext">Basic concept of obtaining K-corrections</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#IDL_routines_for_SDSS.2C_GALEX.2C_2MASS.2C_DEEP2.2C_and_GOODS_users"><span class="tocnumber">7</span> <span class="toctext">IDL routines for SDSS, GALEX, 2MASS, DEEP2, and GOODS users</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Lower-level_IDL_routines_for_K-corrections_and_photo-z.27s_of_arbitrary_data"><span class="tocnumber">8</span> <span class="toctext">Lower-level IDL routines for K-corrections and photo-z's of arbitrary data</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Other_useful_utilities_in_the_IDL_library"><span class="tocnumber">9</span> <span class="toctext">Other useful utilities in the IDL library</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Stand-alone_C_code"><span class="tocnumber">10</span> <span class="toctext">Stand-alone C code</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#kcorrect_C_library"><span class="tocnumber">11</span> <span class="toctext">kcorrect C library</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Filter_curves"><span class="tocnumber">12</span> <span class="toctext">Filter curves</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Absolute_calibration_and_its_uncertainty_in_SDSS_magnitudes"><span class="tocnumber">13</span> <span class="toctext">Absolute calibration and its uncertainty in SDSS magnitudes</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Linear_relationships_between_different_band_systems"><span class="tocnumber">14</span> <span class="toctext">Linear relationships between different band systems</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Known_problems"><span class="tocnumber">15</span> <span class="toctext">Known problems</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#Acknowledgements"><span class="tocnumber">16</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#Frequently_Asked_Questions"><span class="tocnumber">17</span> <span class="toctext">Frequently Asked Questions</span></a></li>
</ul>
</td></tr></tbody></table><script>if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } </script>
<h2> <span class="mw-headline" id="General_description"> General description </span></h2>
<p>This page describes the IDL version of the kcorrect software, which
is no longer under development. There
is now a <a href="https://kcorrect.readthedocs.io">Python
version</a> that you use instead.</p>
<p>The code and results are described in a <a href="http://adsabs.harvard.edu/abs/2007AJ....133..734B" rel="nofollow">paper in the Astronomical Journal</a>.
</p><p>This IDL code fits very restricted spectral energy distribution 
models to galaxy photometry or spectra in the restframe UV, optical and 
near-infrared. The main purpose of the fits are for calculating 
K-corrections, which the code does as well.
The templates it uses for the fits may also be interpreted physically, 
since they are based on the Bruzual-Charlot stellar evolution synthesis 
codes. Thus, for each fit galaxy we can provide an estimate of the 
stellar mass-to-light ratio.
</p><p>The easiest interface to the code, if it is available to you, is the IDL code. Detailed <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html" rel="nofollow">documentation</a>
 is available for all of the routines. For users of the IDL version of 
the code, we have special high-level routines to handle data from a 
number of commonly used surveys: SDSS, GALEX, 2MASS, DEEP2 and GOODS. 
However, the lower level IDL routines are written generally enough that 
one can use those routine to handle data from any survey in the 
restframe UV, optical, or near-infrared.
</p><p>The lowest level code compiles into a shared object library 
callable by C, so that non-IDL users can incorporate the K-correction 
routines directly into their code. It is possible in principle to link 
the C libraries into code based on SM, TCL/Tk, or Python, and I would be
 interested in helping interested parties to do this.
</p><p>One can imagine using the results of this code to calculate the 
evolution of the luminosity function, the distribution of galaxy colors,
 as well as to develop galaxy classification algorithms.
</p>
<h2> <span class="mw-headline" id="What.27s_new_in_v4"> What's new in v4 </span></h2>
<p>There are three main things that are new in the latest version:
</p>
<ol><li> The templates have been extended to work in the rest-frame 
ultraviolet, and still work in the optical and near infrared. In 
particular, our templates are consistent with data at low redshift from 
GALEX, SDSS, and 2MASS can be explained by our templates, and with data 
up to redshifts of 1.5 or 2.0 in DEEP2 and GOODS.
</li><li> Because they are based on unaltered stellar evolution 
synthesis results from Bruzual-Charlot models, the fits have a natural 
physical meaning and one can make physical conclusions about recent 
star-formation histories and stellar masses.
</li><li> The <a href="#Absolute_calibration_and_its_uncertainty_in_SDSS_magnitudes" title="Kcorrect">SDSS AB corrections</a> have changed somewhat.
</li><li> I have added a bunch of higher level IDL routines to perform 
common tasks, like K-correcting SDSS data, GOODS data, GALEX data, DEEP2
 data, and 2MASS data, in addition to taking SDSS data and simulating 
DEEP2 or GOODS observations at higher redshift. When possible, users 
should stick to these high-level routines.
</li></ol>
<p>The new templates were obtained using a clever algorithm called 
"nonnegative matrix factorization," which finds the best set of N 
nonnegative templates which can be linearly, nonnegatively combined to 
explain a set of data. Think of it as "nonnegative PCA." However, it has
 the advantage over PCA that you can account explicitly for the 
uncertainties in the data. In our case, we use a basis set for the 
templates which consists of predictions of stellar evolution synthesis 
models, but you could simply use a set of discrete delta functions if 
you liked. This method has a bunch of potential applications in 
astronomy. The code is NMF_SPARSE in <a href="http://sdss.org/dr12/software/idlutils" rel="nofollow">idlutils</a>.
</p>
<h2> <span class="mw-headline" id="Conditions_of_use"> Conditions of use </span></h2>
<p>Conditions of using the code released here are to send your email
address to mb144@nyu.edu, to cite <a href="http://adsabs.harvard.edu/abs/2007AJ....133..734B" rel="nofollow">Blanton et al. 2007</a>, and to specify the
version tag (eg. v4_3) of the code used. (You can check this in the IDL
code using the <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_VERSION" rel="nofollow">k_version</a> command).  Note that a
previous version of the kcorrect paper existed (<a href="http://adsabs.harvard.edu/abs/2003AJ....125.2348B">Blanton et al. 2003</a>) which
you need only cite if you are using v3_2 or earlier.
</p>
<h2> <span class="mw-headline" id="Obtaining_the_software"> Obtaining the software </span></h2>
<p>First off, if you are downloading the code, please register it. Do so by sending your email address to <a href="mailto:mb144@nyu.edu" rel="nofollow">mb144@nyu.edu</a>.
 No other information is required. I want this because it will allow me 
to contact users in case of any improvements or bug fixes.
</p><p>Note that the IDL code depends on the <a href="http://sdss.org/dr12/software/idlutils" rel="nofollow">idlutils</a>
 package. The best way to obtain the code is to simply download the 
latest version from this site. The tagged and released versions, from 
latest to earliest, are:
</p>
<ul><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect.v4_3.tar.gz" rel="nofollow">kcorrect.v4_3.tar.gz</a>
</li></ul>
<p>Note that the repository for the code is managed on <a href="http://github.com/blanton144/kcorrect">github</a>.
</p>
<h2> <span class="mw-headline" id="Installing_the_software"> Installing the software </span></h2>
<p>The code has been tested, and compiles and runs on a Red Hat 7.1 OS. 
Little experimentation with other operating systems has been performed. 
Other Linux versions should port very easily, at least. In order to 
compile the code follow these directions:
</p><p>First, set the environmental variables. For example, in bash:  
</p>
<pre>KCORRECT_DIR=/usr/local/kcorrect
PATH=$KCORRECT_DIR/bin:$PATH
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$KCORRECT_DIR/lib
export KCORRECT_DIR
export LD_LIBRARY_PATH
IDL_PATH=$IDL_PATH:+$KCORRECT_DIR/pro
</pre>
<p>or in tcsh:  
</p>
<pre>setenv KCORRECT_DIR /usr/local/kcorrect
setenv PATH $KCORRECT_DIR/bin:$PATH
setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:$KCORRECT_DIR/lib
setenv IDL_PATH ${IDL_PATH}:+$KCORRECT_DIR/pro
</pre>
<p>These default settings may need to be changed on your system as follows:
</p>
<ol><li> <b>KCORRECT_DIR</b>: Simply substitute whatever directory you have downloaded this product into. 
</li><li> <b>PATH</b>: Obviously needed to run the binaries created 
</li><li> <b>LD_LIBRARY_PATH</b>: Required for the stand-alone code, so that the OS can find libkcorrect.so at runtime. 
</li><li> <b>IDL_PATH</b>: Set only if you are using IDL  
</li></ol>
<p>You probably want to put these settings in your .bashrc or .tcshrc 
file. EvilUPS or UPS users can just type "setup -r /usr/local/kcorrect 
kcorrect"
</p><p>Second, type "kevilmake -k" while in $KCORRECT_DIR. Then 
everything should compile At this point, you should be able to open IDL 
and start using the utilities described below, or run the stand-alone C 
code.
</p><p>The IDL code depends on the <a href="http://sdss.org/dr12/software/idlutils" rel="nofollow">idlutils</a> package.
</p><p>Note that the C codes "fit_coeffs.c" and "reconstruct_maggies.c" 
only depend on the K-correction library; thus, you can use them as 
templates for incorporating the K-correction code directly into your C 
code, as long as you include the K-correction library. In fact, you 
would probably put something like "fit_coeffs.c" into your code but 
include the k_reconstruct_maggies() call directly inside to get the 
K-corrections.
</p><p>There is a known problem with compiling the stand-alone C code on a Mac OS X system. See <a href="#Known_problems" title="Kcorrect">Known problems</a> for a description.
</p>
<h2> <span class="mw-headline" id="Basic_concept_of_obtaining_K-corrections"> Basic concept of obtaining K-corrections </span></h2>
<div class="thumb tright"><div class="thumbinner" style="width:252px;"><a href="250px-Demo.gif" class="image"><img alt="Demo.gif" src="250px-Demo.gif" class="thumbimage" height="251" width="250"></a>  <div class="thumbcaption"><div class="magnify"><a href="250px-Demo.gif" class="internal" title="Enlarge"><img src="Kcorrect%20-%20NYU%20CCPP%20Wiki_files/magnify-clip.png" alt="" height="11" width="15"></a></div></div></div></div>
<p>I'll describe the basic idea before getting into exactly how to use the code.
</p><p>If you want to convert apparent magnitudes in band R to absolute 
magnitudes in band Q, you need to calculate the K-correction, which is 
defined by the equation:
</p>
<center><i>m</i><sub>R</sub> = <i>M</i><sub>Q</sub> + DM<i>(z)</i> + <i>K</i><sub>QR</sub><i>(z)</i>, </center>
<p>where <i>m</i><sub>R</sub> is the apparent magnitude, <i>M</i><sub>Q</sub> is the absolute magnitude, DM<i>(z)</i> is the distance modulus, accounting for the angular diameter distance and cosmological surface-brightness dimming, and <i>K</i><sub>QR</sub><i>(z)</i>
 is the K-correction. By absolute magnitude we mean: the apparent 
magnitude in band Q the object would have if it were observed at rest, 
10 pc away, using an aperture that contains its total flux. The distance
 modulus accounts for the difference between an object's actual distance
 and 10 pc. The K-correction accounts for the fact that you observed a 
redshifted galaxy in band R but the absolute magnitude requires a 
rest-frame observation in band Q. Obviously the difference between the 
fluxes observed in different bandpasses is fully determined by the 
galaxy SED and the description of the bandpasses. See <a href="http://adsabs.harvard.edu/abs/2002astro.ph.10394H" rel="nofollow">Hogg et al. (2002)</a> for a full description of what the K-correction is.
</p><p>In order to get the appropriate SED for a set of galaxy fluxes, 
kcorrect fits an SED which is a nonnegative linear combination of some 
small number of templates. The templates have been optimized to minimize
 the residuals between the actual galaxy fluxes and the galaxy fluxes 
reconstructed from the galaxy SED fit. The units of the fit spectra 
created are in ergs cm<sup>−2</sup> s<sup>−1</sup> A<sup>−1</sup>.
</p><p>As an example, consider the figure below. I have taken actual 
spectra from the SDSS and projected them onto the g, r, and i bandpasses
 (since these are the ones the spectrum overlaps). Then I have run <a href="http://cosmo.nyu.edu/blanton/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a> (in this case version v3_2) and tried to reconstruct the spectrum. What <a href="http://cosmo.nyu.edu/blanton/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a>
 does here is to fit the nonnegative sum of three (carefully chosen) 
templates to the g, r, and i fluxes. The black line is the original 
spectrum, the red is the reconstructed. As you can see, the fit is 
reasonable.
</p><p>I designed the code so it could calculate K-corrections from some
 set of observed AB bands to those same bands shifted by an arbitrary 
redshift, if so desired. For example, for the SDSS spectroscopic survey,
 most galaxies are observed near redshift 0.1; it makes sense, 
therefore, to K-correct to bandpasses shifted by 0.1 (ie. by a factor 
1.1). This procedure minimizes errors in the estimated K-corrections, 
because the galaxies at z=0.1 will then have a K-correction which 
independent of their SEDs (and therefore their colors) and equal to 
−2.5log<sub>10</sub>(1+0.1). In general, for a bandpass shifted by z_0, 
the K-correction for a galaxy at z_0 to the observed bandpass shifted by
 z_0 is −2.5log<sub>10</sub>(1+z_0), independent of galaxy SED. A bandpass <i>b</i> shifted by redshift z is denoted <i><sup>z</sup>b</i> (as in <i><sup>0.1</sup>g</i>).
</p><p>The inputs to the code are used AB maggies. These are the ratio 
of the source to the AB standard source in each band. To relate these 
quantities to magnitudes, an object with total flux <i>f</i> in maggies has magnitude
</p>
<center><i>m</i> = − 2.5 log<sub> 10</sub> <i>f</i> .</center>
<p>An advantage of the maggie unit system is that it is linear, and thus
 can when necessary accommodate negative flux estimates. Two notes:
</p>
<ol><li> As discussed below, SDSS catalog numbers are NOT on our best 
guess for the AB system. A set of offsets must be applied to the 
magnitudes to achieve our best guess. Our high level IDL code deals with
 this automatically.
</li><li> SDSS catalog magnitudes obtained from the official survey 
database are luptitudes, which for reasonably bright objects are 
equivalent to magnitudes. While maggies are simply related to magnitudes
 by 10<sup>−0.4m</sup>, the conversion from luptitudes to maggies is a bit more complicated; see the description accompanying the <a href="http://www.sdss.org/dr2/" rel="nofollow">DR2 documentation</a>). Our high level IDL code deals with these conversions automatically.
</li></ol>
<p>But you may still be wondering what I mean by an "AB" magnitude. The 
AB system is designed such that a flat spectrum object with <span class="texhtml"><i>f</i><sub>ν</sub></span> = 3631 Jy = 3.631 × 10<sup>−20</sup> ergs cm<sup>−2</sup> s<sup>−1</sup> Hz<sup>−1</sup>
 should have every magnitude equal to zero. The beauty of the AB system 
is that the uniform definition makes it convenient to synthesize AB 
magnitudes from theory or models. The tragic flaw is that the quality of
 the AB-ness of a system is very dependent on precise spectrophotometry 
of standards and the carefulness of the calibrators, since no objects 
have a flat spectrum. There is a tension between these two needs --- 
similar to other tensions throughout astronomy between making precise 
measurements and making interpretable ones.
</p><p>Finally, I have also included code to calculate photometric 
redshifts based on the templates. This procedure is as simple as running
 the K-correction code at each redshift and finding that redshift which 
provides the best fit in the <span class="texhtml">χ<sup>2</sup></span> sense.
</p>
<h2> <span class="mw-headline" id="IDL_routines_for_SDSS.2C_GALEX.2C_2MASS.2C_DEEP2.2C_and_GOODS_users"> IDL routines for SDSS, GALEX, 2MASS, DEEP2, and GOODS users </span></h2>
<p>The easiest interface to the code, if it is available to you, is the IDL code. The detailed <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html" rel="nofollow">documentation</a> is available for all of the routines. The IDL code depends on the <a href="http://sdss3.org/dr8/software/idlutils.php" rel="nofollow">idlutils</a> package.
</p><p>The following routines exist:
</p>
<ol><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS_KCORRECT" rel="nofollow">sdss_kcorrect</a>: SDSS K-corrections 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS2BESSELL" rel="nofollow">sdss2bessell</a>: Take SDSS <i>ugriz</i> fluxes and return Bessell <i>UBVRI</i> fluxes
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS_KPHOTOZ" rel="nofollow">sdss_kphotoz</a>: SDSS photometric redshifts 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#GALEX_KCORRECT" rel="nofollow">galex_kcorrect</a>: GALEX+SDSS K-corrections 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#TWOMASS_KCORRECT" rel="nofollow">twomass_kcorrect</a>: 2MASS+SDSS K-corrections 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#GST_KCORRECT" rel="nofollow">gst_kcorrect</a>: GALEX+SDSS+2MASS kcorrections 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#DEEP_KCORRECT" rel="nofollow">deep_kcorrect</a>: DEEP K-corrections 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS2DEEP" rel="nofollow">sdss2deep</a>: Take local SDSS observations and return fluxes which would be observed in DEEP at some given redshift. 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#GOODS_KCORRECT" rel="nofollow">goods_kcorrect</a>: GOODS K-corrections 
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS2GOODS" rel="nofollow">sdss2goods</a>: Take local SDSS observations and return fluxes which would be observed in GOODS at some given redshift. 
</li></ol>
<p>In all cases I have tried to make the inputs as close to the catalogs
 that the user might be using, and in the form of a structure passed by 
the user. The code calls routines like the following to handle the 
transformations:
</p>
<ol><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS_TO_MAGGIES" rel="nofollow">sdss_to_maggies</a>
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#GALEX_TO_MAGGIES" rel="nofollow">galex_to_maggies</a>
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#TWOMASS_TO_MAGGIES" rel="nofollow">twomass_to_maggies</a>
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#DEEP_TO_MAGGIES" rel="nofollow">deep_to_maggies</a>
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#GOODS_TO_MAGGIES" rel="nofollow">goods_to_maggies</a>
</li></ol>
<p>As noted in the documentation, these routines sometimes perform corrections to the AB system (such as the <a href="#Absolute_calibration_and_its_uncertainty_in_SDSS_magnitudes" title="Kcorrect">small corrections for the SDSS</a>
 and the transformation from the Vega system in 2MASS). Also, they tend 
to add small uncertainties in quadrature with all of the uncertainties 
in order not to overfit to possible calibration errors. Sometimes they 
require the <a href="http://skymaps.info/" rel="nofollow">Schlegel, Finkbeiner and Davis dustmaps</a>
 to be correctly installed on you system. Finally, they try to recognize
 the usual error flags and set inverse variances to zero where 
appropriate. The K-correction routines do output the maggies and inverse
 variances they calculate in the "omaggies" and "oivar" keywords.
</p><p>In the case of SDSS, I provide both calibObj structure inputs (like those used by the <a href="http://photo.astro.princeton.edu/" rel="nofollow">Princeton reductions</a> and the <a href="http://sdss.physics.nyu.edu/vagc" rel="nofollow">NYU-VAGC</a>) and tsObj inputs (like those used by the <a href="http://das.sdss.org/" rel="nofollow">Data Archive Servers)</a>. I don't ever use the <a href="http://cas.sdss.org/" rel="nofollow">Catalog Archive Server</a>
 but would be happy to add an input structure for people who do if you 
let me know what columns to assume is in it. In the meanwhile, basically
 anything called "Counts" in the tsObj structure corresponds to anything
 called "Mag" in the CAS. Note the oddity that COUNTS_MODEL corresponds 
to modelMag.
</p><p>These K-correction and photometric redshift routines will also 
return absolute magnitudes (and inverse variances of the same). To do so
 it assumes Ω<sub>m</sub> = 0.3 and Ω<sub>Λ</sub> = 0.7 (though these can be set differently on input). Absolute magnitudes are reported minus 5log<sub>10</sub>(h) (where H<sub>o</sub> = h*100 km/s/Mpc), with h=1 (ie, to use H<sub>0</sub>=72 km/s/Mpc one has add 5log<sub>10</sub>(.72) to the output of the code).
</p><p>You will also note some outputs having to do with mass-to-light ratios and masses.
</p>
<h2> <span class="mw-headline" id="Lower-level_IDL_routines_for_K-corrections_and_photo-z.27s_of_arbitrary_data"> Lower-level IDL routines for K-corrections and photo-z's of arbitrary data </span></h2>
<p>All the above K-correction and photometric redshift routines use the same basic engines, <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a> and <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KPHOTOZ" rel="nofollow">kphotoz</a>.
 These routines uses SDSS filters by default but allow any type to be 
input. To perform K-corrections for other sets of bandpasses (say, the 
Bessell bandpasses or 2MASS bandpasses), look for them in 
$KCORRECT_DIR/data/filters and insert them in the <i>filterlist=</i> flag.
</p><p>As an example of using <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a>, one might do the following:
</p><p><br> 
</p>
<pre>kcorrect, [1., 4.78, 10.96, 14.45, 19.05],  $
          [1100., 28., 7.7, 4.4, 2.5], $
          0.03, kcorrect, band_shift=0.1, chi2=chi2
</pre>
<p>which would take the set of maggies in the first argument, observed 
for a galaxy at redshift 0.03, and return the K-corrections to the <i>ugriz</i>
 magnitudes shifted by 0.1. This choice of maggies and uncertainties 
should return a good chi^2. Note that it is a nonnegative fit, so linear
 goodness of fit measures don't exactly apply.
</p><p>Please note that <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a>
 uses a lot of overhead (2-3 seconds worth), so if you can, use it on 
several thousand galaxies simultaneously at least. If you use it on each
 object individually (as in the example given above), you will be in 
trouble. If you truly cannot avoid it, then specify the extra arguments 
rmatrix and zvals. For example, if you run the following:
</p><p><br> 
</p>
<pre>kcorrect, [1., 4.78, 10.96, 14.45, 19.05],  $
          [1100., 28., 7.7, 4.4, 2.5], $
          0.03, kcorrect, band_shift=0.1, chi2=chi2, $
          rmatrix=rmatrix, zvals=zvals, vname=vname
kcorrect, [1., 4.73, 11.26, 14.25, 18.85],  $
          [1100., 28., 7.7, 4.4, 2.5], $
          0.03, kcorrect, band_shift=0.1, chi2=chi2, $
          rmatrix=rmatrix, zvals=zvals, vname=vname
</pre>
<p>You will find that the second call takes far less time than the 
first, because the temporary data stored in rmatrix and zvals will not 
have to be regenerated. The <a href="#IDL_routines_for_SDSS.2C_GALEX.2C_2MASS.2C_DEEP2.2C_and_GOODS_users" rel="nofollow">high-level routines</a> I discuss above all maintain common blocks which store rmatrix and zvals for you so you don't have to worry about this.
</p><p>If you want to look at the fit spectrum, then specify vmatrix, lambda, and coeffs. The commands
</p><p><br> 
</p>
<pre>kcorrect, [1., 4.78, 10.96, 14.45, 19.05],  $
          [1100., 28., 7.7, 4.4, 2.5], $
          0.03, kcorrect, band_shift=0.1, chi2=chi2, $
          vmatrix=vmatrix, lambda=lambda, coeffs=coeffs
plot, lambda, vmatrix#coeffs, xra=[2000., 12000.]
</pre>
<p>will plot the best fit spectrum. You can also just call <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_LOAD_VMATRIX" rel="nofollow">k_load_vmatrix</a> to get the templates.
</p><p>If you want to project that spectrum onto a new set of bandpasses, use <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_RECONSTRUCT_MAGGIES" rel="nofollow">k_reconstruct_maggies</a>. For example, to project back onto the SDSS bandpasses, the command
</p><p><br> 
</p>
<pre>k_reconstruct_maggies, coeffs, 0.03, maggies, vmatrix=vmatrix, $
    lambda=lambda, filterlist=['sdss_u0.par', 'sdss_g0.par', $
    'sdss_r0.par', 'sdss_i0.par', 'sdss_z0.par']
</pre>
<p>will pass back the reconstruction in the array maggies. You can project onto any bandpasses you want. For example,
</p><p><br> 
</p>
<pre>k_reconstruct_maggies, coeffs, 0.03, maggies, vmatrix=vmatrix, $
    lambda=lambda, filterlist=['bessell_B.par', 'bessell_V.par']
vega2ab=k_vega2ab(filterlist=['bessell_B.par', 'bessell_V.par'],/kurucz)
bessellmags=-2.5*alog10(maggies)-vega2ab
BminusV=bessellmags[0]-bessellmags[1]
</pre>
<p>will yield the Vega B-V for the best fit.
</p><p>Fitting photometric redshifts just requires fitting the coefficients for a number of redshifts and minimizing the &amp;chi<sup>2</sup> residuals for the fits. I provide the IDL routine <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KPHOTOZ" rel="nofollow">kphotoz</a> to do so (similar to the <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a> routine). For example, one might do the following:
</p><p><br> 
</p>
<pre>kphotoz, [1., 4.78, 10.96, 14.45, 19.05],  $
         [1100., 28., 7.7, 4.4, 2.5], $
         photoz
</pre>
<p>Again, there is large overhead, so one-at-a-time is not the way to call <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KPHOTOZ" rel="nofollow">kphotoz</a>. As for <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a>, you can avoid spending this overhead more than once either by feeding it lists of objects or as follows:
</p><p><br> 
</p>
<pre>kphotoz, [1., 4.78, 10.96, 14.45, 19.05],  $
         [1100., 28., 7.7, 4.4, 2.5], $
         photoz, rmatrix=rmatrix, zvals=zvals, vname=vname
kphotoz, [1., 4.78, 10.96, 14.45, 19.05],  $
         [1100., 28., 7.7, 4.4, 2.5], $
         photoz, rmatrix=rmatrix, zvals=zvals, vname=vname
</pre>
<p>By default, <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KPHOTOZ" rel="nofollow">kphotoz</a> uses a very simple prior (equal to the redshift z) to push the fits away from z=0. You can turn this off with the flag <i>/noprior</i>, or specify your own prior using the inputs <i>zprior</i> (which indicates the redshift grid) and <i>lprior</i> (which indicates the natural log of the prior).
</p><p>A piece of advice on the <i>type</i> of magnitudes to use for 
SDSS photometric redshifts. For modern versions of PHOTO (v5_4 and 
later) it is best to simply use the model magnitudes for all galaxies. 
(And indeed this is what we use in <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#SDSS_KPHOTOZ" rel="nofollow">sdss_kphotoz</a>).
</p><p>Users of kcorrect v3_2 will hopefully find that I retained 
backwards compatibility. Please note that the calling procedure has 
changed since v1_16, in the sense that inputting maggies is now the 
default.
</p>
<h2> <span class="mw-headline" id="Other_useful_utilities_in_the_IDL_library"> Other useful utilities in the IDL library </span></h2>
<p>In addition to the K-correction tools, kcorrect has some other useful tools in it:
</p>
<ol><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_PROJECT_FILTERS" rel="nofollow">k_project_filters()</a> is a standalone IDL routine to project a spectrum onto a filter.
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_SMOOTH" rel="nofollow">k_smooth</a> smooths a spectrum with a Gaussian.
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_SOLAR_MAGNITUDES" rel="nofollow">k_solar_magnitudes()</a> calculates Solar absolute magnitudes in any filter.
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_VEGA2AB" rel="nofollow">k_vega2ab()</a> provides conversions between AB and Vega magnitudes.
</li><li> <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#LF_DISTMOD" rel="nofollow">lf_distmod()</a> calculates distance moduli given a redshift and cosmology.
</li><li> A number of useful routines (mostly starting with "lf_") exist for calculating luminosity functions.
</li><li> There are various pieces of code (not all written by me) for reading in certain types of data files, like <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#K_IM_READ_BC03%28%29" rel="nofollow">Bruzual-Charlot predictions</a> (by John Moustakas), <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#READ_DRAINE" rel="nofollow">Bruce Draine's PAH spectra</a>, <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#READ_PEG.PRO" rel="nofollow">PEGASE2 predictions</a> (by Alex Quintero), <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#WITT_EXT" rel="nofollow">Witt-Gordon multiple-scattering dust extinction predictions</a>, and <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#READ_MAPPINGS" rel="nofollow">Mappings-III style emission line fluxes</a>.
</li></ol>
<h2> <span class="mw-headline" id="Stand-alone_C_code"> Stand-alone C code </span></h2>
<p>The C code requires a bit more attention to use. If people say they 
would use it if it were easier, I will improve it. In this section, I 
will describe the stand-alone C programs which fit for the coefficients 
and which calculate the reconstructed maggies. In the next section, I 
will briefly describe how to use the libraries within your own C code.
</p><p>There are two stand-alone programs, <i>fit_coeffs</i> and <i>reconstruct_maggies</i>. <i>fit_coeffs</i> uses the maggies in each band to calculate the coefficients. <i>reconstruct_maggies</i> uses the list of coefficients (as output by <i>fit_coeffs</i> to reconstruct the magnitudes.
</p><p><i>fit_coeffs</i> has a help flag:
</p><p><br> 
</p>
<pre>apeiron.[kcorrect].7&nbsp;% fit_coeffs --help
Usage: cat  | fit_coeffs [--vfile vfile --lfile lfile
            --ffile ffile ]
</pre>
<p>As indicated, you would call it like
</p><p><br> 
</p>
<pre>cat maggies.dat | fit_coeffs
</pre>
<p>where each line of "maggies.dat" has the form:
</p><p><br> 
</p>
<pre>redshift umaggies gmaggies rmaggies imaggies zmaggies uinvvar ginvvar rinvvar iinvvar zinvvar
</pre>
<p>All of the quantities in this file are in maggies, as described 
above. So you have to convert the luptitudes or magnitudes --- and the 
inverse variances --- into maggies before calling this. (Note that the 
conversion to the inverse variances from the maggies and the magnitude 
errors is (0.4 ln(10) × maggies × magerr)<sup>-2</sup>).
</p><p>From the set of maggies and errors, the code calculates a set of 
four coefficients which correspond to its guess about the nature of the 
galaxy SED. The coefficients are output to standard out in the form:
</p><p><br> 
</p>
<pre>redshift coeff0 coeff1 coeff2 coeff3 coeff4
</pre>
<p>where the redshift is included for reasons which will be clear soon.
</p><p>Once you have the coefficients, you can calculate the 
reconstructed maggies for a galaxy with the same SED and same total 
flux, observed at any redshift through a shifted bandpass, using <i>reconstruct_maggies</i>. The help flag for <i>reconstruct_maggies</i> yields
</p><p><br> 
</p>
<pre>apeiron.[kcorrect].8&nbsp;% reconstruct_maggies --help
Usage: cat  | reconstruct_maggies [--vfile vfile --lfile lfile
            --ffile ffile --band-shift band_shift --redshift redshift]
</pre>
<p>So you can call it like:
</p><p><br> 
</p>
<pre>cat coeffs.dat | reconstruct_maggies
</pre>
<p>where coeffs.dat is in the same format as the output to <i>fit_coeffs</i>: 
</p><p><br> 
</p>
<pre>redshift coeff0 coeff1 coeff2
</pre>
<p>The optional parameter "band_shift" specifies the bandpasses to 
reconstruct (band_shift=0., the default, indicates to use the observed 
frame bandpasses). "redshift" specifies the redshift at which to observe
 the galaxy (by default, the input redshift is used). The output is in 
the form:
</p><p><br> 
</p>
<pre>redshift u_rec g_rec r_rec i_rec z_rec
</pre>
<p>in the original maggy units.
</p><p>To summarize with an example, if you wanted to calculate the 
K-corrections from the observed bandpasses to rest-frame bandpasses 
shifted by 0.1, you could call the code as follows:
</p><p><br> 
</p>
<pre>cat $KCORRECT_DIR/test/sample.dat | fit_coeffs | reconstruct_maggies &gt;! maggies.dat
cat $KCORRECT_DIR/test/sample.dat | fit_coeffs | reconstruct_maggies --band-shift 0.1 --redshift 0. &gt;! maggies.z0.dat
</pre>
<p>The K-corrections are then defined by −2.5 log<sub>10</sub>(maggies/maggies.z0).
</p><p>You can use the <b>ffile</b> option to reconstruct_maggies to 
specify a file which contains a list of the filters to use (by default, 
it uses the SDSS filters).
</p><p>The stand-alone program <i>fit_photoz</i> works in the same way as <i>fit_coeffs</i>: 
</p><p><br> 
</p>
<pre>apeiron.[v3_1].27&nbsp;% fit_photoz --help
Usage: cat  | fit_photoz [--vfile  --lfile
            --ffile  ]
</pre>
<p>As in:
</p><p><br> 
</p>
<pre>cat maggies.dat | fit_photoz
</pre>
<p>where in this case each line of "maggies.dat" has the form:
</p><p><br> 
</p>
<pre>umaggies gmaggies rmaggies imaggies zmaggies uinvvar ginvvar rinvvar iinvvar zinvvar
</pre>
<p>The output is again to standard out and is of the form:
</p><p><br> 
</p>
<pre>photoz coeff0 coeff1 coeff2
</pre>
<p>The same rules apply here as to the IDL code: call the code for many 
objects at a time, or else the overhead (about 3 seconds) will kill you.
</p><p>As I noted above, I have not worked very hard to make the stand-alone C code or the C library <i>very</i>
 usable, as generally speaking that would have meant replicating 
features in IDL and C, and I wasn't sure how many people would use the 
pure C versions. If there is a need to do this, I might be convinced to 
-- or if YOU do it, we could include your stuff in the library.
</p>
<h2> <span class="mw-headline" id="kcorrect_C_library"> kcorrect C library </span></h2>
<p>Why would you bother incorporating the K-correction code into your 
code at all, rather than just calculating the K-corrections once and 
reading in the results? Well, perhaps you have to calculate 1/Vmax, in 
which for each object you have to check its K-correction at (nearly) 
arbitrary redshifts. It is best to calculate the K-corrections on the 
fly in these cases, so we provide ways of doing this through a shared 
object libary.
</p><p>For example, the stand-alone C code uses the "libkcorrect.so" 
library (in fact, this is *exactly* the same library which is linked 
into IDL). If you have this library in your LD_LIBRARY_PATH and you 
include the header file "kcorrect.h" (in $KCORRECT_DIR/include), your 
own code can call it. The best way to figure out how to use it is to 
read the examples in fit_coeffs.c and reconstruct_maggies.c, but I'll 
try to explain the essentials here.
</p><p>1.First, the code has to have the basic information about the 
templates. You will usually be using the "default" templates in 
$KCORRECT_DIR/data/templates, so you will have to load in the files:  
</p>
<pre>$KCORRECT_DIR/data/templates/vmatrix.default.dat
$KCORRECT_DIR/data/templates/lambda.default.dat
</pre>
<p>These files are in a <a href="http://cosmo.nyu.edu/blanton/kcorrect/ascii.html" rel="nofollow">special ASCII format</a> which can be read into a "float*" variable in C using the routine k_load_ascii_table. For example:  
</p>
<pre>k_load_ascii_table(&amp;vmatrix,&amp;ndim,&amp;sizes,vmatrixfile);
</pre>
<p>loads in a set of data from vmatrixfile. The pointer to the data is 
returned in "vmatrix". The number of dimensions in the data is returned 
in "ndim". "sizes" is an array of size ndim giving the size of each 
dimension. The information in each of these files is the following:
</p>
<ul><li> lambda.default.dat: The wavelength scale covered by the templates (the *edges*, not centers, of all pixels) [NLAMBDA+1]
</li><li> vmatrix.default.dat: The spectra spanning the SED space [NV,NLAMBDA]
</li></ul>
<p>2. Second, it is necessary to read in the filters. The list of filters is in the directory:  
</p>
<pre>$KCORRECT_DIR/data/templates/sdss_filters.dat
</pre>
<p>This list is read by the routine "k_load_filters", which assumes all 
the filters are in the directory $KCORRECT_DIR/data/filters (or if 
KCORRECT_DIR is not set, in the current directory). This routine is 
called as:  
</p>
<pre>k_load_filters(&amp;filter_n,&amp;filter_lambda,&amp;filter_pass,&amp;maxn,&amp;nk,filterfile);
</pre>
<p>"nk" is the number of filters. "filter_n" is the number of points in 
each filter curve, "filter_lambda" is the wavelength scale of each 
filter, and "filter_pass" is the response curve of each filter. "maxn" 
is the maximum of "filter_n". This sets the indexing of "filter_lambda" 
and "filter_pass", so that to get the ith wavelength of the kth filter 
you access "filter_lambda[k*maxn+i]".
</p><p>3. Third, you have to define the redshift range over which you 
are going to define a look-up table. I usually use 0. to 1., to be safe,
 with 1000 steps, using the code:  
</p>
<pre>zvals=(float *) malloc(nz*sizeof(float));
for(i=0;i&lt;nz;i++)
  zvals[i]=zmin+(zmax-zmin)*((float)i+0.5)/(float)nz;
</pre>
<p>where nz=1000, zmin=0., and zmax=1.
</p><p>4. Finally, you have to define the look-up table which tabulates 
the projection of each basis element in the bmatrix onto each filter, at
 each redshift in zvals:  
</p>
<pre>rmatrix=(float *) malloc(nz*nv*nk*sizeof(float));
k_projection_table(rmatrix,nk,nv,vmatrix,lambda,nl,zvals,nz,filter_n,
                   filter_lambda,filter_pass,band_shift,maxn);
</pre>
<p>One defines "nv" and "nl" based on the "sizes" returned by the k_load_ascii_table calls described above.
</p><p>Once this overhead has been taken care of (and it is a 
significant amount of time --- a few seconds --- so only do it once!) 
you can use the routines <b>k_fit_nonneg</b> and <b>k_reconstruct_maggies</b>.
</p><p><b>k_fit_nonneg</b> is called as:  
</p>
<pre>k_fit_nonneg(coeffs, rmatrix, nk, nv, zvals, nz, maggies, maggies_ivar,
            redshift, ngalaxy, tolerance, maxiter, niter, chi2,
            verbose)
</pre>
<p>The array coeffs should be of the size (nv*ngalaxy), and the coefficients are returned in it.
</p><p><b>k_reconstruct_maggies</b> is called as:  
</p>
<pre>k_reconstruct_maggies(zvals, nz, rmatrix, nk, nv, coeffs, redshift,
                      reconstruct_maggies, ngalaxy)
</pre>
<p>where reconstruct_maggies are expressed in maggies.
</p><p>The photo-z code can also be accessed through the C library libkcorrect.so.  Instead of <i> k_fit_coeffs</i>, you will be calling <i>k_fit_photoz</i>, as in:
</p>
<pre>k_fit_photoz(photoz, coeffs, rmatrix, nk, nv, zprior, lprior, nprior,
             zvals, nz, maggies, maggies_ivar, ngalaxy, tolerance,
             maxiter, niter, chi2, verbose)
</pre>
<p>zprior, lprior, and nprior should contain the prior grid to use.
</p><p>As I noted above, I have not worked very hard to make the stand-alone C code or the C library <i>very</i>
 usable, as generally speaking that would have meant replicating 
features in IDL and C, and I wasn't sure how many people would use the 
pure C versions. If there is a need to do this, I might be convinced to 
-- or if YOU do it, we could include your stuff in the library.
</p>
<h2> <span class="mw-headline" id="Filter_curves"> Filter curves </span></h2>
<p>It is of course necessary to have filter responses to do any of this 
work. Thus, in kcorrect I have put together a fairly large library of 
filter curves in a homogeneous format. I have tried as far as possible 
to provide the provenance of all of these curves, though it has not 
always been possible to figure out.
</p><p>The files are in a special SDSS format called FTCL described at <a href="http://www.sdss.org/dr2/data/parfiles.html" rel="nofollow">the SDSS DR2 site</a>. IDL code (in particular, yanny_readone()) exists in <a href="http://sdss3.org/dr8/software/idlutils.php" rel="nofollow">idlutils</a> to read in such files.
</p><p>It turns out that the SDSS filters do not have the responses they were designed to have, but <a href="http://www.ioa.s.u-tokyo.ac.jp/%7Edoi/" rel="nofollow">Mamoru Doi</a>
 has done the hard work of measuring them. Jim Gunn then took these, ran
 them through models of the telescope and the atmosphere (using an 
appropriately scaled model of the Palomar atmospheric model at airmass 
1.3). Daniel Eisenstein deserves special mention for the extensive 
testing he has done on these. We have a <a href="https://github.com/blanton144/kcorrect/tree/master/data/filters" rel="nofollow">repository</a> of these and other curves. For <a href="http://cosmo.nyu.edu/blanton/kcorrect/kcorrect_help.html#KCORRECT" rel="nofollow">kcorrect</a> we use the SDSS files:
</p><p><br> 
</p>
<pre>sdss_u0.par
sdss_g0.par
sdss_r0.par
sdss_i0.par
sdss_z0.par
</pre>
<p>The other SDSS files refer to the responses for each camcol.
</p>
<h2> <span class="mw-headline" id="Absolute_calibration_and_its_uncertainty_in_SDSS_magnitudes"> Absolute calibration and its uncertainty in SDSS magnitudes </span></h2>
<p>Our best estimate (from Eisenstein's work on hot white dwarfs) of the
 absolute calibration of SDSS data indicates that the magnitudes output 
by the SDSS pipeline code are not exactly on an AB system. There are 
offsets Delta m = m_AB - m_SDSS = [-0.036, 0.012, 0.010, 0.028, 0.040] 
in u, g, r, i, and z bands. Note these numbers have changed since v3_2. 
We have trained our templates on SDSS magnitudes corrected to this 
system. For the moment we recommend that the user apply these 
corrections to the magnitudes they are using.
</p><p>In addition, we always apply minimum uncertainty of [0.05, 0.02, 0.02, 0.02, 0.03] mag in <i>ugriz</i>
 (the high level routines SDSS_KCORRECT, etc. already do so). This is 
because there is always an uncertainty in the calibration of any given 
galaxy, and we don't want the templates working super-hard to fit (say) 
some unrealistically small error bar in one band at the expense of the 
other bands.
</p>
<h2> <span class="mw-headline" id="Linear_relationships_between_different_band_systems"> Linear relationships between different band systems </span></h2>
<p>Using this code on a number of SDSS galaxies, we have estimated the 
linear relationships between a number of different bandpass systems. The
 <a href="http://adsabs.harvard.edu/abs/2007AJ....133..734B" rel="nofollow">kcorrect paper</a> has a table with these relationships.
</p>
<h2> <span class="mw-headline" id="Known_problems"> Known problems </span></h2>
<p>14. The sdss_kcorrect.pro utility documentation string
	claims that its "mag" and "err" inputs should be in asinh magnitudes. However,
	it treats them as Pogson magnitudes. To correctly use the "mag" and "err"
	inputs (as opposed to inputting fluxes or structures), those should be
	Pogson magnitudes. Thanks to Patricio Gallardo for pointing this out!
</p>
<p>13. <a href="http://www.atnf.csiro.au/people/Russell.Jurek/WP_CT.html" rel="nofollow">Russell Jurek</a> reports the following, which I believe is applicable to Mac OS
X 10.9 and kcorrect v4_2 or later. Thanks to Anne Jaskot for pointing
this out.
</p>
<pre> kcorrect: kcorrect installs using a `kevilmake' script in the installation's bin directory. 
 I had to tweak the kevilmake script in order to get it to compile. I changed the F77 
 compiler from g77 to gfortan, which negates the need to use the -lcc_dynamic compiler 
 flag. Delete all mention of -lcc_dynamic in the compiler flags, otherwise you'll get errors 
 and the library won't build. Don't forget to follow the instructions and comment in both 
 sets of lines required to compile the kcorrect C library. Note that I've only confirmed that 
 this will allow me to compile/create the kcorrect C library.
</pre>
<p>12. Edd Edmondson and Tom Melvin report that with v4_2 and IDL 8.1 on
 Ubuntu 10.04.4, there is a problem with building libkcorrect.so:
</p>
<pre> undefined reference to `__stack_chk_fail_local'
</pre>
<p>They report that the code builds if X_CFLAGS for Linux in kevilmake includes:
</p>
<pre> -fno-stack-protector
</pre>
<p>11. In v4_2 and earlier, the default compilation flags don't work for
 Mac OS X Lion (Darwin version == 11).  Marla Geha tells us that adding 
the following works:
</p>
<pre>      if [ `uname -r | cut -c 1,2` == 11 ]; then
                LD=gcc
                X_LD_FLAGS="-dynamiclib -undefined dynamic_lookup -force_cpusubtype_ANY -single_module"
      fi
</pre>
<p><br>
10. In v4_2 and earlier, the routine deep_kcorrect.pro does not treat 
the "filterlist" input correctly.  Thanks to Joanna Woo for pointing 
this out. If it is once called with a given filterlist input during an 
IDL session, it will keep using that filterlist forever, no matter what 
inputs you give it.  This will be fixed in future releases, but for now 
can be fixed by changing the common block:
</p>
<pre> common com_deep_kcorrect, out_rmatrix, out_zvals, band_shift, $
   deep_rmatrix, deep_zvals, vname, out_filterlist
</pre>
<p>9. In v4_2 and earlier, the DEEP2 filters are incorrect (per energy instead of per photon).  The <a href="https://github.com/blanton144/kcorrect/tree/master/data/filters" rel="nofollow">versions on the kcorrect trunk</a> are correct.  (Thanks to Renbin Yan for fixing).
</p><p>8. In v4_2 and earlier, kevilmake parses 'uname -r' incorrectly 
when building on Snow Leopard or above (any Darwin version &gt;= 10).  
Users will want to edit kevilmake to force the 64-bit option.  Genevieve
 Graves kindly solved this problem:
</p>
<pre>      "Darwin" )
              F77=g77
              SO_EXT=dylib
              X_LD_FLAGS="-bundle /usr/lib/bundle1.o -L/usr/lib  
-L/usr/lib/gcc/powerpc-apple-darwin8/4.0.0 -lc -lgcc -flat_namespace 
-undefined suppress"
              X_CFLAGS="-g -Wall -dynamic"
              if [ `uname -r | cut -c 1` \&lt; 8 ]; then
                      X_LD_FLAGS="-bundle /usr/lib/bundle1.o -L/usr/lib 
-lc -lcc_dynamic -flat_namespace -undefined suppress"
#      Uncomment the following two lines to get .dylib libraries that 
can
#      be linked into C programs on a Mac OS X system
#                  LD=libtool
#                  X_LD_FLAGS="-dynamic -L/usr/lib -lc -lcc_dynamic"
              fi
              if [ `uname -r | cut -c 1` == 9 ]; then
                X_LD_FLAGS="-bundle -flat_namespace -undefined suppress"
#      Uncomment the following two lines to get .dylib libraries that 
can
#      be linked into C programs on a Mac OS X system
#     LD=libtool
#     X_LD_FLAGS="-dynamic -L/usr/lib -lc "
              fi
              if [ `uname -r | cut -c 1,2` == 10 ]; then
                  LD=libtool
                  X_LD_FLAGS="-dynamic -L/usr/lib -lc "
              fi
              SDSS_CFLAGS=&nbsp;;;
</pre>
<p>7. In v4_2 and earlier, Linux 64-bit boxes fail with the message:  
</p>
<pre>ld -shared -o /u/rreyes/IDL/kcorrect/lib/libkcorrect.so 
idl_k_projection_table.o k_projection_table.o idl_k_fit_spec.o 
k_fit_spec.o idl_k_fit_nonneg.o k_fit_nonneg.o idl_k_fit_photoz.o 
k_fit_photoz.o idl_k_reconstruct_maggies.o k_reconstruct_maggies.o 
k_strparse.o k_yanny_readone.o k_filter_struct.o k_fileopen.o 
k_load_filters.o k_read_ascii_table.o k_nonneg_solve.o k_interpolate.o 
idl_k_binspec.o k_binspec.o k_utils.o k_qromo.o k_midpnt.o k_choldc.o 
k_cholsl.o k_locate.o k_brent.o k_evolve.o k_zbrent.o k_polint.o 
idl_lf_calc_vmax.o idl_ztoV.o idl_Vtoz.o idl_z2dm.o idl_z2t.o idl_t2z.o 
idl_lf_eep.o idl_lf_select_eep.o ztransform.o iterate_lf.o philike.o 
phierrors_lf.o gaussj.o lf_select_eep.o lf_calc_vmax.o lf_eep.o 
lf_eepfit.o lf_WH_interp.o lf_set_AB.o lf_sum_AB.o
ld: k_projection_table.o: relocation R_X86_64_32 against `k_midpnt' can 
not be used when making a shared object; recompile with -fPIC
k_projection_table.o: could not read symbols: Bad value
make[1]: *** [/u/rreyes/IDL/kcorrect/lib/libkcorrect.so] Error 1
</pre>
<p>You want to edit the Linux section of kevilmake so it reads:  
</p>
<pre>	"Linux" )
		SO_EXT=so
		X_CFLAGS="-fPIC -g -Wall"
		X_FFLAGS="-ffixed-line-length-none"
		SDSS_CFLAGS=
		X_LD_FLAGS=-shared&nbsp;;;
</pre>
<p>Or just use the idlutils "evilmake" utility (if you are using the IDL version of kcorrect you need idlutils installed anyway).
</p><p>6. There is a known problem with compiling the stand-alone C code
 on a Mac OS X 10.4 system or earlier, which results in the following 
error message: 
</p>
<pre>cc -I/Users/blanton/kcorrect/include -I/Users/blanton/kcorrect/src -g
-Wall -dy namic -O3 -DCHECK_LEAKS -o
/Users/blanton/kcorrect/bin/fit_photoz fit_photoz.c - lm
-L/Users/blanton/kcorrect/lib \ -lkcorrect ld:
/Users/blanton/kcorrect/lib/libkcorrect.dylib is input for the dynamic
link editor, is not relocatable by the static link editor again make:
*** [/Users/blanton/kcorrect/bin/fit_photoz] Error 1 make: Target
`all' not remade because of errors. 
</pre>
<p>I am honestly not really sure what causes this. The library 
libkcorrect.dylib is fine for importing into IDL but NOT for importing 
into the stand-alone C code. If you want the library to be built 
correctly for importing into C programs, you can uncomment the two lines
 in the "kevilmake" script:
</p>
<pre>#   Uncomment the following two lines to get .dylib libraries that can
#   be linked into C programs on a Mac OS X system
#		LD=libtool
#		X_LD_FLAGS="-dynamic -L/usr/lib -lc -lcc_dynamic"
</pre>
<p>In this case, the library will be fine for importing into C but no 
good for using from IDL. I can't make the Mac do both with a single 
library file. Sorry! If somebody knows how to do this, PLEASE let me 
know.
</p><p>4. In Mac OS X 10.5 (Leopard), there occurred some changes to the
 gcc libraries, which require  the following addition to "kevilmake" at 
the end of the "Darwin" section:
</p>
<pre>    if [ `uname -r | cut -c 1` == 9 ]; then
     X_LD_FLAGS="-bundle -flat_namespace -undefined suppress"
#      Uncomment the following two lines to get .dylib libraries that can
#      be linked into C programs on a Mac OS X system
#     LD=libtool
#     X_LD_FLAGS="-dynamic -L/usr/lib -lc "
   fi
</pre>
<p><br>
5. In v3_2 and earlier, fit_coeffs sends output to stdout occasionally of the form:  
</p>
<pre>ERROR: choldc failed (sum==-1.197184e+06)
</pre>
<p>which screws up the inputs to reconstruct_maggies. If this affects you, change the line in k_choldc.c:  
</p>
<pre>printf("ERROR: choldc failed (sum==%e)\n",sum);
</pre>
<p>to  
</p>
<pre>fprintf(stderr, "ERROR: choldc failed (sum==%e)\n",sum);
</pre>
<p>4. In versions v1_10 and earlier, the code returned K-corrections to 
non-AB systems (oops!). Back in those days, Ivan Baldry pointed out that
 kcorrect returned non-AB magnitudes when it was requested to output 
K-corrections to shifted bandpasses. The sense of the error was that the
 K-correction was missing a term of −2.5 log<sub>10</sub> (1+z) for a 
bandpass shift of z_0. This error occurred independent of bandpass, 
color, redshift, and anything else. Thus, when interpreting magnitudes 
returned by kcorrect v1_10 and earlier, please apply a correction of 
−2.5 log<sub>10</sub> (1+<i>z</i>), where z_0 is the shift of the bandpass (eg. <i><sup>z</sup>b</i> is the <i>b</i>-band shifted by <i>z</i>).
 Luckily this only is an error in the absolute measures of magnitude; 
colors are unchanged, the shapes of LFs are unchanged (just shifted in 
magnitude), etc. Many thanks to Ivan for pointing out the error.
</p><p>3. In v4_1_4 and earlier, the twomass_*.par filter curves are off
 by a factor of lambda, because apparently the 2MASS web site posted 
energy-counting filter curves (but called them photon-counting).  Fixed 
in v4_2 and later.
</p><p>2. In v4_1_4 and earlier, there was a problem with calculating 
projections onto bandpasses that caused in some cases "jitter" (high 
frequency noise as a function of redshift at the sub-percent level). 
Fixed in v4_2 and later.
</p><p>1. In v4_2 and earlier, a bug exists in sdss_kphotoz.pro, where 
"mags" on line 146 should read "mag." This affects the usage of 
magnitude inputs into the code instead of maggies.  Thanks to Jon 
Loveday for pointing out the error.
</p>
<h2> <span class="mw-headline" id="Acknowledgements"> Acknowledgements </span></h2>
<p>This work was funded in part by a GALEX Archival research grant (Program 38).
</p><p>Sam Roweis provided irreplaceable help in teaching me the 
algorithms used in this code. David Hogg tracked down many of the 
bandpass responses given here. Ivan Baldry was critical to debugging the
 code. Hewett and Warren provided a bandpass response for the b<sub>j</sub>
 band. Thanks to Alison Coil, Jeff Newman, and Risa Wechsler for help 
understand and using the DEEP2 data. Thanks to Lexi Moustakas for help 
using the GOODS catalog -- and the GOODS team for access to that 
catalog. Thanks to John Moustakas for his code for reading in 
Bruzual-Charlot templates.
</p><p>Funding for the Sloan Digital Sky Survey (SDSS) has been provided
 by the Alfred P. Sloan Foundation, the Participating Institutions, the 
National Aeronautics and Space Administration, the National Science 
Foundation, the U.S. Department of Energy, the Japanese Monbukagakusho, 
and the Max Planck Society. The SDSS Web site is <a href="http://www.sdss.org/" rel="nofollow">http://www.sdss.org/</a>.
</p><p>The SDSS is managed by the Astrophysical Research Consortium 
(ARC) for the Participating Institutions. The Participating Institutions
 are The University of Chicago, Fermilab, the Institute for Advanced 
Study, the Japan Participation Group, The Johns Hopkins University, Los 
Alamos National Laboratory, the Max-Planck-Institute for Astronomy 
(MPIA), the Max-Planck-Institute for Astrophysics (MPA), New Mexico 
State University, University of Pittsburgh, Princeton University, the 
United States Naval Observatory, and the University of Washington.
</p><p>This publication makes use of data products from the Two Micron 
All Sky Survey, which is a joint project of the University of 
Massachusetts and the Infrared Processing and Analysis Center/California
 Institute of Technology, funded by the National Aeronautics and Space 
Administration and the National Science Foundation.
</p><p>The Galaxy Evolution Explorer (GALEX) is a NASA Small Explorer. 
The mission was developed in cooperation with the Centre National 
d'Etudes Spatiales of France and the Korean Ministry of Science and 
Technology.
</p><p>DEEP2 is a collaboration between UC Santa Cruz and UC Berkeley. 
Funding for the DEEP2 survey has been provided by NSF grant AST-0071048 
and AST-0071198. (Some of) the data presented herein were obtained at 
the W.M. Keck Observatory, which is operated as a scientific partnership
 among the California Institute of Technology, the University of 
California and the National Aeronautics and Space Administration. The 
Observatory was made possible by the generous financial support of the 
W.M. Keck Foundation. The DEEP2 team and Keck Observatory acknowledge 
the very significant cultural role and reverence that the summit of 
Mauna Kea has always had within the indigenous Hawaiian community and 
appreciate the opportunity to conduct observations from this mountain.
</p>
<h2> <span class="mw-headline" id="Frequently_Asked_Questions"> Frequently Asked Questions </span></h2>
<p><b>Why do I get a compilation error in K_LOAD_FILTERS?</b>
</p>
<pre>filter_str=yanny_readone(curr_path+'/'+filterlist[i],hdr=hdr, $    
                                                              ^
% Syntax error.
 At: /Applications/kcorrect/pro/utils/k_load_filters.pro, Line 70 
% 1 Compilation error(s) in module K_LOAD_FILTERS.
</pre>
<p>Because you do not have <a href="http://sdss3.org/dr8/software/idlutils.php" rel="nofollow">idlutils</a>
installed.  Install the idlutils package (you don't need the idlspec2d or anything else
described on the above web page).
</p><p><b>kcorrect assumes h=1. How do I change that?</b>
</p><p>For calculating absolute magnitudes, kcorrect uses a Hubble constant 
<span class="texhtml"><i>H</i><sub>0</sub> = 100<i>h</i></span> km/s/Mpc
with <span class="texhtml"><i>h</i> = 1</span>, whereas in the actual Universe <span class="texhtml"><i>h</i> = 0.7</span> or so.  
In order to convert the kcorrect outputs to your desired value of <span class="texhtml"><i>h</i></span>
you need to apply the term:
</p><p><span class="texhtml"><i>M</i>(<i>h</i>) = <i>M</i>(<i>h</i> = 1) + 5log<sub>10</sub><i>h</i></span>
</p><p>In this formula <span class="texhtml"><i>M</i>(<i>h</i> = 1)</span> is the output of kcorrect 
and <span class="texhtml"><i>M</i>(<i>h</i>)</span> is the absolute magnitude you want.
That is, for a fixed flux 
the actual absolute magnitudes are brighter (i.e. you have
to subtract about <span class="texhtml">0.77</span> mag)
than the 
kcorrect outputs, because the Hubble constant is smaller, and 
thus things are further away.
</p><p><b>How can I project onto filter XXX?</b>
</p>
<pre>; First enumerate the filters you want to project onto:
fs = ['galex_FUV.par','bessell_U.par','bessell_B.par']

; Then project the SEDs into the variable maggies
k_projection_table, maggies, vm # coeffs, lambda, redshifts, fs, zmin=0,zmax=0,nz=1
</pre>
<p>lambda, vm and coeffs come from the routine kcorrect.
</p><p>redshifts &amp; fs are from you.  zmin,zmax and nz are set so 
	that you will be given the  maggies at the redshifts you specify.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 278/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

</body></html>
